<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.15">
  <POU Name="PRG_FileLogger" Id="{2c2df95d-219a-4cf8-8822-b07cbb83b944}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM PRG_FileLogger
VAR
    // Start/Stop edge
    bLogStartOld   : BOOL := FALSE;
    bLogStopOld    : BOOL := FALSE;

    // Saat
    fbLocalTime    : Tc2_Utilities.FB_LocalSystemTime;
    tsNow          : TIMESTRUCT;

    // File FB'leri
    fbOpen         : FB_FileOpen;
    fbWrite        : FB_FileWrite;
    fbClose        : FB_FileClose;
    hFile          : UINT := 0;

    // State machine
    fileState      : INT := 0;   // 0 idle, 10 open, 30 log, 90 close
    writeState     : INT := 0;   // 0 idle, 1 start write, 2 wait

    // Chunk ayarları
    C_CHUNK_SIZE   : UINT := 50;
    chunkCount     : UINT := 0;
    idx            : UDINT;
    iSens          : UINT;

    // küçük string parçaları (255 altı!)
    sPiece         : STRING(80);

    // BYTE buffer (uzun satırlar burada)
    aBuf           : ARRAY[0..16383] OF BYTE;   // 16 KB
    nBufLen        : UDINT := 0;

    // Yazılacak buffer seçimi
    pWriteBuff     : PVOID;
    nWriteLen      : UDINT;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[// =============================
// PLC saatini sürekli güncelle
// =============================
fbLocalTime(bEnable := TRUE);
fbLocalTime();
IF fbLocalTime.bValid THEN
    tsNow := fbLocalTime.systemTime;
END_IF;


// =============================
// Start / Stop edge detect
// =============================
IF g_bLogStart AND NOT bLogStartOld THEN
    g_bLogging       := TRUE;
    g_epochOffsetMs  := 0;
    g_wrIndex        := 0;
    g_rdIndex        := 0;
    g_bufferOverflow := FALSE;
    
    // Log başlangıcında base epoch (eğer kullanıyorsan)
    g_epochBaseMs := F_TimeStructToUnixMs(tsNow);

    // Dosya ismi
    g_sFileName := UINT_TO_STRING(tsNow.wDay);
    g_sFileName := CONCAT(g_sFileName, UINT_TO_STRING(tsNow.wMonth));
    g_sFileName := CONCAT(g_sFileName, UINT_TO_STRING(tsNow.wYear MOD 100));
    g_sFileName := CONCAT(g_sFileName, '-');
    g_sFileName := CONCAT(g_sFileName, UINT_TO_STRING(tsNow.wHour));
    g_sFileName := CONCAT(g_sFileName, '_');
    g_sFileName := CONCAT(g_sFileName, UINT_TO_STRING(tsNow.wMinute));
    g_sFileName := CONCAT(g_sFileName, '_');
    g_sFileName := CONCAT(g_sFileName, UINT_TO_STRING(tsNow.wSecond));
    g_sFileName := CONCAT(g_sFileName, '.csv');

    g_sPath := CONCAT(g_sBasePath, g_sFileName);

    g_headerPending := TRUE;
    g_lineReady     := FALSE;

    writeState := 0;
    fileState  := 10;
END_IF;

IF g_bLogStop AND NOT bLogStopOld THEN
    g_bLogging := FALSE;
END_IF;

bLogStartOld := g_bLogStart;
bLogStopOld  := g_bLogStop;


// =============================
// DOSYA / YAZMA STATE MACHINE
// =============================
CASE fileState OF

    0: ; // IDLE

    // -------------------------
    // 10: Dosyayı aç
    // -------------------------
    10:
        fbOpen.sNetId    := '';
        fbOpen.sPathName := g_sPath;
        fbOpen.nMode     := FOPEN_MODEWRITE OR FOPEN_MODETEXT; // CREATE yok, WRITE yeterli
        fbOpen.bExecute  := TRUE;
        fbOpen();
        fbOpen.bExecute  := FALSE;
        fileState := 11;

    11:
        fbOpen();
        IF NOT fbOpen.bBusy THEN
            IF fbOpen.bError THEN
                fileState := 0;
            ELSE
                hFile := fbOpen.hFile;
                fileState := 30;
            END_IF
        END_IF


    // -------------------------
    // 30: LOGGING
    // -------------------------
    30:
        // ---- A) Yazma state ----
        CASE writeState OF
            0:
                IF g_lineReady THEN
                    writeState := 1;
                END_IF

            1:
                fbWrite.sNetId     := '';
                fbWrite.hFile      := hFile;
                fbWrite.pWriteBuff := pWriteBuff;
                fbWrite.cbWriteLen := nWriteLen;
                fbWrite.bExecute   := TRUE;
                fbWrite();
                fbWrite.bExecute   := FALSE;
                writeState := 2;

            2:
                fbWrite();
                IF NOT fbWrite.bBusy THEN
                    g_lineReady := FALSE;
                    writeState  := 0;
                END_IF
        END_CASE


        // ---- B) Yeni yazılacak şey hazırla ----
        IF (writeState = 0) AND (NOT g_lineReady) THEN

            // ======================
            // 1) HEADER (BYTE buffer)
            // ======================
            IF g_headerPending THEN

                nBufLen := 0;

                // "TimeMs" (aslında EpochMs yazmak istersen burayı değiştir)
                sPiece := 'TimeMs';
                MEMCPY(ADR(aBuf[nBufLen]), ADR(sPiece), LEN(sPiece));
                nBufLen := nBufLen + LEN(sPiece);

                // ",ValueX" kolonları
                FOR iSens := 1 TO C_NUM_SENSORS DO
                    sPiece := ',Value';
                    sPiece := CONCAT(sPiece, UINT_TO_STRING(iSens));
                    MEMCPY(ADR(aBuf[nBufLen]), ADR(sPiece), LEN(sPiece));
                    nBufLen := nBufLen + LEN(sPiece);
                END_FOR

                // newline
                sPiece := '$N';
                MEMCPY(ADR(aBuf[nBufLen]), ADR(sPiece), LEN(sPiece));
                nBufLen := nBufLen + LEN(sPiece);

                pWriteBuff  := ADR(aBuf);
                nWriteLen   := nBufLen;
                g_lineReady := TRUE;

                g_headerPending := FALSE;

            ELSE

                // ======================
                // 2) DATA CHUNK (BYTE buffer)
                // ======================
                g_bufferUsed := g_wrIndex - g_rdIndex;

                IF g_bufferUsed > 0 THEN
                    nBufLen    := 0;
                    chunkCount := 0;

                    WHILE (chunkCount < C_CHUNK_SIZE) AND (g_rdIndex < g_wrIndex) DO
                        // 🔴 ÖNEMLİ: index artık UDINT, cast yok
                        idx := g_rdIndex MOD C_BUFFER_SIZE;

                        // TimeMs / EpochMs
                        sPiece := ULINT_TO_STRING(g_aTimeBuffer[idx]);
                        MEMCPY(ADR(aBuf[nBufLen]), ADR(sPiece), LEN(sPiece));
                        nBufLen := nBufLen + LEN(sPiece);

                        // tüm sensörler
                        FOR iSens := 1 TO C_NUM_SENSORS DO
                            sPiece := ',';
                            MEMCPY(ADR(aBuf[nBufLen]), ADR(sPiece), LEN(sPiece));
                            nBufLen := nBufLen + LEN(sPiece);

                            sPiece := LREAL_TO_STRING(g_aValBuffer[idx, iSens]);
                            MEMCPY(ADR(aBuf[nBufLen]), ADR(sPiece), LEN(sPiece));
                            nBufLen := nBufLen + LEN(sPiece);
                        END_FOR

                        // newline
                        sPiece := '$N';
                        MEMCPY(ADR(aBuf[nBufLen]), ADR(sPiece), LEN(sPiece));
                        nBufLen := nBufLen + LEN(sPiece);

                        g_rdIndex  := g_rdIndex + 1;
                        chunkCount := chunkCount + 1;

                        // buffer taşmasın – aBuf en az 16000 ise 15000 sınırı güvenli
                        IF nBufLen > 15000 THEN
                            EXIT;
                        END_IF
                    END_WHILE

                    pWriteBuff  := ADR(aBuf);
                    nWriteLen   := nBufLen;
                    g_lineReady := TRUE;

                ELSE
                    // Buffer boş & logging de OFF ise → dosyayı kapat
                    IF NOT g_bLogging THEN
                        fileState := 90;
                    END_IF
                END_IF
            END_IF
        END_IF


    // -------------------------
    // 90: Dosyayı kapat
    // -------------------------
    90:
        fbClose.sNetId   := '';
        fbClose.hFile    := hFile;
        fbClose.bExecute := TRUE;
        fbClose();
        fbClose.bExecute := FALSE;
        fileState := 91;

    91:
        fbClose();
        IF NOT fbClose.bBusy THEN
            hFile    := 0;
            fileState := 0;
        END_IF

END_CASE
]]></ST>
    </Implementation>
    <LineIds Name="PRG_FileLogger">
      <LineId Id="4695" Count="224" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>